#!/usr/bin/perl
use strict;

# Sixgill: Static assertion checker for C/C++ programs.
# Copyright (C) 2009-2010  Stanford University
# Author: Brian Hackett
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# build an entire project using the xgill plugin to generate source databases.

#################################
# environment specific settings #
#################################

# expected cwd for this script.
my $use_cwd = "/path/to/project";

# code to do a clean build of the project from $use_cwd.
sub build_project {
    system("make clean");
    system("make");
}

# directory containing gcc wrapper scripts.
my $wrap_dir = "/path/to/wrap_gcc";
die "Bad wrapper directory: $wrap_dir" if (not (-e "$wrap_dir/basecc"));

# soft memory limit for the manager, in MB. 0 for no limit.
my $memory_limit = 0;

##########################
# general purpose script #
##########################

my $usage = "USAGE: build_xgill result-dir\n";
my $result_dir = shift or die $usage;
die "Need output directory: $result_dir\n" if (not (-d $result_dir));

# make sure we're running from the expected directory.
my $cwd = `pwd`;
chomp $cwd;
die "Bad working directory, run from: $use_cwd\n" if ($cwd ne $use_cwd);

# fork so we can run the manager and build in separate processes.
defined(my $pid = fork) or die "Can't fork";
if (!$pid) {
    # this is the child process, start the manager.

    # change to the output directory so all the databases end up there.
    chdir $result_dir or die;

    my $mem_str = "";
    $mem_str = "-memory-limit=$memory_limit" if ($memory_limit != 0);

    # redirecting the output here means that $pid in the parent refers to
    # a shell process rather than an xmanager process directly.
    exec("xmanager $mem_str > $result_dir/build_manager.log");
}

# this is the parent process, perform the build.

# figure out the IP address to use for workers to connect to the manager.
# we need to read the manager's log file, will be the first line.
# give the manager one second to start up, any longer and something's broken.
sleep(1);
my $manager_log = `cat $result_dir/build_manager.log`;
$manager_log =~ /Listening on ([\.\:0-9]*)/ or die "Missing manager";
my $address = $1;

# write the configuration file for the wrapper script.
open(CONFIG, "> $wrap_dir/xgill.config");
print CONFIG "$use_cwd\n";
print CONFIG "$result_dir/build_xgill.log\n";
print CONFIG "$address\n";
close(CONFIG);

# update the PATH so that the build sees the wrappers.
$ENV{"PATH"} = "$wrap_dir:" . $ENV{"PATH"};

# do the clean build.
build_project();

# signal the manager that it's over.
system("xsource -remote=$address -end-manager") or die;

# wait for the manager to clean up and finish termination.
print "Waiting for manager to finish...\n";
waitpid($pid, 0);
