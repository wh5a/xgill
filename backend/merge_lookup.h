
// Sixgill: Static assertion checker for C/C++ programs.
// Copyright (C) 2009-2010  Stanford University
// Author: Brian Hackett
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#pragma once

#include "backend_compound.h"

NAMESPACE_XGILL_BEGIN

/////////////////////////////////////////////////////////////////////
// Merge caches
/////////////////////////////////////////////////////////////////////

// data about a single object of type T in a MergeExternalLookup below.
template <class T, class U, class V>
struct MergeExternalData
{
  // key for this database entry. holds a reference.
  T *key;

  // single V object stored in this database entry. holds a reference.
  // NULL if there are zero or more than one V objects.
  V *single;

  // map from U objects to each of the V objects in this database entry.
  // holds a reference on V object (not the U object, which the V object
  // itself must hold a reference on). NULL if there are zero or one
  // V objects.
  HashTable<U*, V*, HashObject> *map;

  MergeExternalData()
    : key(NULL), single(NULL), map(NULL)
  {}
};

// lookup structure for a merge cache. a merge cache is one which
// is used exclusively for writing and merging new data into a
// database, and not for looking up existing values from that database.
// when a lookup is performed on the cache an empty value is returned.
// the client can subsequently modify that value and release it back
// to the cache, and eventually flush the cache out to write merged
// data back to the database.
// template classes:
// T: object with which a database key is uniquely associated.
//    each database key stores one or more values of type V.
// U: object key uniquely identifying an object of type V.
// V: object being grown and modified by the merge cache.
template <class T, class U, class V>
class MergeExternalLookup
  : public HashCache<T*,MergeExternalData<T,U,V>*,HashObject>::ExternalLookup
{
 public:
  // type of the cache this is a lookup for.
  typedef HashCache<T*,MergeExternalData<T,U,V>*,HashObject> Cache;

 public:
  MergeExternalLookup(const char *db_name);

  // get whether a recent Flush() on this lookup generated data to merge.
  bool HasFlushData() { return !m_flush_data.Empty(); }

  // add to t any actions required to lookup all the database keys specified
  // by the values from a recent Flush().
  void ReadKeys(Transaction *t);

  // read in the list of database entries generated by ReadKeys() and
  // now stored in transaction t, merge this old data with the new data
  // produced by Flush(), and add to nt any actions needed to
  // write out the merged data.
  void WriteKeys(Transaction *nt, Transaction *t);

  // check whether all writes made by WriteKeys went through. a write will
  // fail if the database entry has been modified since the point at which
  // the read transaction ran. in this case the entry will be added back
  // to the cache.
  void CheckWrite(Transaction *nt, Cache *cache);

  // get the object associated with an identifying object key within
  // the data for a database key. makes an empty one if force is set and 
  // there is no such object. after this call no reference is held on the
  // cache so RemoveLruEntries(), Clear() or other cache methods can
  // invalidate the return pointer.
  V* LookupSingle(Cache *cache, T *database_key, U *object_key,
                  bool force = true);

  // inherited methods. don't call these directly.
  void LookupInsert(Cache *cache, T *key);
  void Remove(Cache *cache, T *key, MergeExternalData<T,U,V> *data);

 public:
  // virtual functions which must be overloaded by subclasses.

  // get the unique identifying key for the specified object.
  virtual U* GetObjectKey(V *object) = 0;

  // get a reference on an empty object for the specified identifying key.
  virtual V* MakeEmpty(U *object_key) = 0;

  // return the key in the database to use for storing v.
  // this key must be unique to v.
  virtual const char* GetDatabaseKey(T *key) = 0;

  // merge the specified new data with the data in old_data,
  // and store the result in merged_data.
  virtual void MergeData(MergeExternalData<T,U,V> *new_data,
                         Buffer *old_data, Buffer *merged_data) = 0;

 public:
  // utility functions for use by MergeData.

  // get the V object associated with U and mark that entry
  // (the mark mangles the V pointer in new_data). requires the entry
  // is not already marked.
  V* LookupMarkData(MergeExternalData<T,U,V> *new_data,
                    U *object_key);

  // fill unmarked_entries with all V objects in new_data which were
  // not marked by a call to LookupMarkData. also clears marks from all
  // entries in new_data.
  void GetUnmarkedData(MergeExternalData<T,U,V> *new_data,
                       Vector<V*> *unmarked_entries);

 private:
  // internal implementation data.

  // name of the database this is merging data into.
  const char *m_db_name;

  // whether we have enabled timestamps on the database yet.
  bool m_enabled_timestamps;

  // all entries removed from the most recent flush.
  Vector<MergeExternalData<T,U,V>*> m_flush_data;

  // read transaction result for the contents of all keys in m_flush_data.
  // the result list contents are one-to-one with m_flush_data.
  size_t m_data_list_result;

  // write transaction result for whether each write of the merged data
  // went through.
  size_t m_success_list_result;

  // scratch buffers for use in merging.
  Buffer m_scratch_old;
  Buffer m_scratch_new;
};

#include "merge_lookup_impl.h"

NAMESPACE_XGILL_END
