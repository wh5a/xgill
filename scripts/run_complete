#!/usr/bin/perl

# Sixgill: Static assertion checker for C/C++ programs.
# Copyright (C) 2009-2010  Stanford University
# Author: Brian Hackett
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# do a complete run of the system from raw source to reports. this requires
# various run_monitor processes to be running in the background (maybe on other
# machines) and watching a shared poll_file for jobs. if the output directory
# for this script already exists then an incremental analysis will be performed
# and the reports will only reflect the changes since the earlier run.

use strict;
use IO::Handle;

#################################
# environment specific settings #
#################################

# poll file shared with the run_monitor script.
my $poll_file = "/path/to/poll-file";

# root directory of the project.
my $build_dir = "/path/to/project";
die "Need build directory: $build_dir\n" if (not -d $build_dir);

# code to clean the project from $build_dir.
sub clean_project {
    system("make clean");
}

# code to build the project from $build_dir.
sub build_project {
    system("make");
}

# directory containing gcc wrapper scripts.
my $wrap_dir = "/path/to/wrap_gcc";
die "Bad wrapper directory: $wrap_dir" if (not (-e "$wrap_dir/basecc"));

# soft memory limit for the manager, in MB. 0 for no limit. this requires
# that USE_COUNT_ALLOCATOR is defined in util/alloc.h
my $memory_limit = 0;

# analysis commands with timeouts to use.
my $xmemlocal = "xmemlocal -timeout=20";
my $xinfer = "xinfer -timeout=60";
my $xcheck = "xcheck -timeout=30";

# output directory to do a diff against. leave as "" for no diffing.
my $old_dir = "";
die "Need old directory: $old_dir\n" if ($old_dir ne "" && not -d $old_dir);

##########################
# general purpose script #
##########################

my $usage = "USAGE: run_complete result-dir\n";
my $poll_file = shift or die $usage;
my $result_dir = shift or die $usage;

my $pid = fork();
if ($pid != 0) {
    print "Forked, exiting...\n";
    exit(0);
}

# if the result directory does not already exist, clean before building.
if (not (-d $result_dir)) {
    clean_project();
    mkdir $result_dir;
}

open(OUT, "> $result_dir/complete.log");
OUT->autoflush(1);  # don't buffer writes to the main log.

# redirect our stdout and stderr to the log.
STDOUT->fdopen(\*OUT, "w");
STDERR->fdopen(\*OUT, "w");

# if you only want to do a partial run, comment out the run_ commands here
# which you don't want to do.

run_build();

chdir $result_dir;

run_pass("xmemlocal", $xmemlocal);
run_pass("xinfer", $xinfer);
run_pass("xcheck_annot", "$xcheck -check-kind=annotation");
run_pass("xcheck_rtime", "$xcheck -check-kind=annotation_runtime");
run_pass("xcheck_oflow", "$xcheck -check-kind=write_overflow");

run_index("index_annot", "annotation");
run_index("index_rtime", "annotation_runtime");
run_index("index_oflow", "write_overflow");
archive_indexes();

close(OUT);

sub run_build
{
    print "build started: ";
    print scalar(localtime());
    print "\n";

chdir $build_dir;

    my $build_log = "$result_dir/build.log";
    my $build_err = "$result_dir/build_err.log";
    system("$build_script $result_dir > $build_log 2> $build_err");

    print "build finished: ";
    print scalar(localtime());
    print "\n";
}

sub run_pass
{
    my ($name, $command) = @_;
    my $log_file = "$result_dir/manager.$name.log";

    # fork off a manager process for the analysis.
    defined(my $pid = fork) or die;

    if (!$pid) {
        # this is the child process, start the manager.
        exec("xmanager > $log_file");
    }

    # can only get here in the parent process. figure out the address of the
    # manager for connecting workers. we need to read the manager's log file,
    # will be the first line. give the manager one second to start up,
    # any longer and something's broken.
    sleep(1);
    my $log_data = `cat $log_file`;
    $log_data =~ /Listening on ([\.\:0-9]*)/ or die;
    my $address = $1;

    # write the configuration file.
    open(POLL, "> $poll_file");
    print POLL "$command\n";
    print POLL "$result_dir/$name\n";
    print POLL "$address\n";
    close(POLL);

    print "$name started: ";
    print scalar(localtime());
    print "\n";

    waitpid($pid, 0);
    unlink($poll_file);

    print "$name finished: ";
    print scalar(localtime());
    print "\n";

    # collate the worker's output into a single file. wait a few seconds first
    # to make sure we get all the worker output.
    sleep(10);
    system("cat $name.*.log > $name.log");
}

# the names of all directories containing reports to archive.
my $indexes;

sub run_index
{
    my ($name, $kind) = @_;

    return if (not (-e "report_$kind.xdb"));

    print "$name started: ";
    print scalar(localtime());
    print "\n";

    # make an index for the report diff if applicable.
    if ($old_dir ne "") {
        system("make_index $kind $old_dir > $name.diff.log");
        system("mv $kind diff_$kind");
        $indexes .= " diff_$kind";
    }

    # make an index for the full set of reports.
    system("make_index $kind > $name.log");
    $indexes .= " $kind";

    print "$name finished: ";
    print scalar(localtime());
    print "\n";
}

sub archive_indexes
{
    print "archive started: ";
    print scalar(localtime());
    print "\n";

    system("tar -czf reports.tgz $indexes");
    system("rm -rf $indexes");

    print "archive finished: ";
    print scalar(localtime());
    print "\n";
}
