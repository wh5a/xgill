#!/usr/bin/perl

# Sixgill: Static assertion checker for C/C++ programs.
# Copyright (C) 2009-2010  Stanford University
# Author: Brian Hackett
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# poll a file looking for jobs to run which were generated by run_complete.
# when there is a suitable job, the file's contents will look like:
#   command to run
#   directory with prefix for log files
#   remote address to run with

use strict;

#################################
# environment specific settings #
#################################

# poll file shared with the run_complete script.
my $poll_file = "/path/to/poll-file";

##########################
# general purpose script #
##########################

my $usage = "USAGE: run_monitor index\n";
my $index = shift or die $usage;

my $pid = fork();
if ($pid != 0) {
    print "Forked, exiting...\n";
    exit(0);
}

while (1) {
    # sleep when there is no job to run.
    if (not (-e $poll_file)) {
        sleep(5);
        next;
    }

    open(IN, "< $poll_file");
    my $command = <IN>;
    my $logprefix = <IN>;
    my $address = <IN>;
    close(IN);

    chomp $command;
    chomp $logprefix;
    chomp $address;

    # check for a well formed address.
    if (!($address =~ /\d+\.\d+\.\d+\.\d+:\d+/)) {
        sleep(5);
        next;
    }

    $command .= " -remote=$address";

    # file to receive log output.
    my $output = "$logprefix.$index.log";

    # whether this is the initial time we ran the command
    # (an initialize transaction will be sent to the manager).
    my $initial = "-initial";

    # run the command until completion.
    while (1) {
        my $res = system("$command $initial >> $output") / 256;
        last if ($res == 0);
        $initial = "";
        print_msg($output, "*** Program terminated with code $res\n");
    }

    print_msg($output, "*** Program terminated normally\n");
    sleep(5);
}

sub print_msg
{
    my $output = shift or die;
    my $msg = shift or die;
    open(OUT, ">> $output");
    print OUT $msg;
    close(OUT);
}
